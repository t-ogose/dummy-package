'use strict';

const node_path = require('node:path');
const chokidar = require('chokidar');
const require$$0 = require('tty');
const pluginutils = require('@rollup/pluginutils');

var picocolorsExports = {};
var picocolors = {
  get exports(){ return picocolorsExports; },
  set exports(v){ picocolorsExports = v; },
};

let tty = require$$0;

let isColorSupported =
	!("NO_COLOR" in process.env || process.argv.includes("--no-color")) &&
	("FORCE_COLOR" in process.env ||
		process.argv.includes("--color") ||
		process.platform === "win32" ||
		(tty.isatty(1) && process.env.TERM !== "dumb") ||
		"CI" in process.env);

let formatter =
	(open, close, replace = open) =>
	input => {
		let string = "" + input;
		let index = string.indexOf(close, open.length);
		return ~index
			? open + replaceClose(string, close, replace, index) + close
			: open + string + close
	};

let replaceClose = (string, close, replace, index) => {
	let start = string.substring(0, index) + replace;
	let end = string.substring(index + close.length);
	let nextIndex = end.indexOf(close);
	return ~nextIndex ? start + replaceClose(end, close, replace, nextIndex) : start + end
};

let createColors = (enabled = isColorSupported) => ({
	isColorSupported: enabled,
	reset: enabled ? s => `\x1b[0m${s}\x1b[0m` : String,
	bold: enabled ? formatter("\x1b[1m", "\x1b[22m", "\x1b[22m\x1b[1m") : String,
	dim: enabled ? formatter("\x1b[2m", "\x1b[22m", "\x1b[22m\x1b[2m") : String,
	italic: enabled ? formatter("\x1b[3m", "\x1b[23m") : String,
	underline: enabled ? formatter("\x1b[4m", "\x1b[24m") : String,
	inverse: enabled ? formatter("\x1b[7m", "\x1b[27m") : String,
	hidden: enabled ? formatter("\x1b[8m", "\x1b[28m") : String,
	strikethrough: enabled ? formatter("\x1b[9m", "\x1b[29m") : String,
	black: enabled ? formatter("\x1b[30m", "\x1b[39m") : String,
	red: enabled ? formatter("\x1b[31m", "\x1b[39m") : String,
	green: enabled ? formatter("\x1b[32m", "\x1b[39m") : String,
	yellow: enabled ? formatter("\x1b[33m", "\x1b[39m") : String,
	blue: enabled ? formatter("\x1b[34m", "\x1b[39m") : String,
	magenta: enabled ? formatter("\x1b[35m", "\x1b[39m") : String,
	cyan: enabled ? formatter("\x1b[36m", "\x1b[39m") : String,
	white: enabled ? formatter("\x1b[37m", "\x1b[39m") : String,
	gray: enabled ? formatter("\x1b[90m", "\x1b[39m") : String,
	bgBlack: enabled ? formatter("\x1b[40m", "\x1b[49m") : String,
	bgRed: enabled ? formatter("\x1b[41m", "\x1b[49m") : String,
	bgGreen: enabled ? formatter("\x1b[42m", "\x1b[49m") : String,
	bgYellow: enabled ? formatter("\x1b[43m", "\x1b[49m") : String,
	bgBlue: enabled ? formatter("\x1b[44m", "\x1b[49m") : String,
	bgMagenta: enabled ? formatter("\x1b[45m", "\x1b[49m") : String,
	bgCyan: enabled ? formatter("\x1b[46m", "\x1b[49m") : String,
	bgWhite: enabled ? formatter("\x1b[47m", "\x1b[49m") : String,
});

picocolors.exports = createColors();
picocolorsExports.createColors = createColors;

const cwd = process.cwd();
const pluginName = "vite:stylelint";
const extnamesWithStyleBlock = [".vue", ".svelte"];
const colorMap = {
  error: "red",
  warning: "yellow",
  plugin: "magenta"
};
const isVirtualModule = (id) => id.startsWith("virtual:") || id.startsWith("\0") || !id.includes("/");
const getFileFromId = (id) => pluginutils.normalizePath(id).split("?")[0];
const shouldIgnore = (id, filter) => {
  if (isVirtualModule(id))
    return true;
  if (!filter(id))
    return true;
  const file = getFileFromId(id);
  if (extnamesWithStyleBlock.some((extname) => file.endsWith(extname))) {
    return !(id.includes("?") && id.includes("type=style"));
  }
  return false;
};
const colorize = (text, textType) => picocolorsExports[colorMap[textType]](text);
const print = (text, textType, context) => {
  console.log("");
  if (context) {
    if (textType === "error")
      context.error(text);
    else if (textType === "warning")
      context.warn(text);
  } else {
    const t = colorize(`${text}  Plugin: ${colorize(pluginName, "plugin")}\r
`, textType);
    console.log(t);
  }
};
const getOptions = ({
  dev,
  build,
  cache,
  cacheLocation,
  include,
  exclude,
  stylelintPath,
  formatter,
  lintInWorker,
  lintOnStart,
  chokidar: chokidar2,
  emitError,
  emitErrorAsWarning,
  emitWarning,
  emitWarningAsError,
  ...stylelintOptions
}) => ({
  dev: dev ?? true,
  build: build ?? false,
  cache: cache ?? true,
  cacheLocation: cacheLocation ?? ".stylelintcache",
  include: include ?? ["src/**/*.{css,scss,sass,less,styl,vue,svelte}"],
  exclude: exclude ?? ["node_modules", "virtual:"],
  stylelintPath: stylelintPath ?? "stylelint",
  formatter: formatter ?? "string",
  lintInWorker: lintInWorker ?? false,
  lintOnStart: lintOnStart ?? false,
  chokidar: chokidar2 ?? false,
  emitError: emitError ?? true,
  emitErrorAsWarning: emitErrorAsWarning ?? false,
  emitWarning: emitWarning ?? true,
  emitWarningAsError: emitWarningAsError ?? false,
  ...stylelintOptions
});
const getFilter = (options) => pluginutils.createFilter(options.include, options.exclude);
const getStylelintLinterOptions = (options) => ({
  ...options,
  allowEmptyInput: true
});
const initialStylelint = async (options) => {
  const { stylelintPath, formatter } = options;
  try {
    const module = await import(stylelintPath);
    const stylelint = (module == null ? void 0 : module.default) ?? module;
    const loadedFormatter = typeof formatter === "string" ? stylelint.formatters[formatter] : formatter;
    return { stylelint, formatter: loadedFormatter };
  } catch (error) {
    throw new Error(
      `Failed to import Stylelint. Have you installed and configured correctly? ${error}`
    );
  }
};
const getLintFiles = (stylelint, formatter, options) => (
  // eslint-disable-next-line sonarjs/cognitive-complexity
  async (files, context) => await stylelint.lint({ ...getStylelintLinterOptions(options), files }).then(async (linterResult) => {
    if (!linterResult || linterResult.results.length === 0)
      return;
    const { emitError, emitErrorAsWarning, emitWarning, emitWarningAsError } = options;
    const result = { ...linterResult };
    let results = linterResult.results.filter((result2) => !result2.ignored);
    if (!emitError) {
      results = results.map((result2) => ({
        ...result2,
        warnings: result2.warnings.filter((warning) => warning.severity !== "error")
      }));
      result.errored = false;
    }
    if (!emitWarning) {
      results = results.map((result2) => ({
        ...result2,
        warnings: result2.warnings.filter((warning) => warning.severity !== "warning")
      }));
    }
    results = results.filter((result2) => result2.warnings.length > 0);
    result.results = results;
    if (results.length === 0)
      return;
    const text = formatter(results, result);
    let textType;
    if (result.errored) {
      textType = emitErrorAsWarning ? "warning" : "error";
    } else {
      textType = emitWarningAsError ? "error" : "warning";
    }
    return print(text, textType, context);
  })
);
const getWatcher = (lintFiles, { include, exclude }) => chokidar.watch(include, { ignored: exclude }).on("change", async (path) => {
  const fullPath = node_path.resolve(cwd, path);
  await lintFiles(fullPath);
});

exports.getFileFromId = getFileFromId;
exports.getFilter = getFilter;
exports.getLintFiles = getLintFiles;
exports.getOptions = getOptions;
exports.getWatcher = getWatcher;
exports.initialStylelint = initialStylelint;
exports.pluginName = pluginName;
exports.shouldIgnore = shouldIgnore;
